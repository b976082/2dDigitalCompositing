# Week4 Class
#### B976082 박순범

# What is LUT?


## **1. LUT?**

 순람표(順覽表) 또는 룩업 테이블(lookup table)은 컴퓨터 과학에서 일반적으로 배열이나 연관 배열로 된 데이터 구조로, 런타임 계산을 더 단순한 배열 색인화 과정으로 대체하는 데 자주 쓰인다. 처리 시간의 절약은 중요할 수 있는데, 이는 메모리로부터 값을 받아오는 것이 더 일이 많이 드는 계산이나 입출력 기능을 거치는 것보다 더 빠르기 때문이다.[1] 테이블들은 정적인 프로그램 저장소에 미리 계산되어 저장하거나, 프로그램 초기화 단계(메모이제이션)의 일부로 계산(프리페치)할 수도 있다. 룩업 테이블은 배열에 위치한 일련의 (올바르거나 올바르지 않은) 값 항목들을 일치시키면서 입력값이 유효한지 확인하는 데 널리 쓰이기도 하며, 프로그래밍 언어에서는 포인터 함수를 포함(또는 레이블로 오프셋)하여 일치하는 입력을 처리할 수 있다. -위키백과-

 LUT를 사용하는 주된 목적은 Log -> Rec.709로의 변환 속도를 **단순화**하기 위해서라고 이해하면 좋다. 지금의 PC 속도라면 이 변환은 함수를 사용해도 큰 무리가 없을 정도로 빠르게 처리해 주지만, 옛날의 PC 만큼의 처리 속도를 가지지 못하는 I/O장비에서는 LUT를 사용하는 것이 더 빠르게 처리할 수 있다.
 
![week4](https://user-images.githubusercontent.com/70869138/94325837-5f4ca280-ffdb-11ea-8952-1a21d085a24a.png)

 왼쪽이 입력값이고, 오른쪽이 출력값이라고 할때 오른쪽 값으로 변환하기 위해서 아래의 함수를 사용한다고 가정해보자.
 
**out = in ^ 2.2**
 
 우리는 위 함수가 얼마나 단순한지 쉽게 이해할 수 있지만, 그래프로 그려볼려면 일일이 값을 대입하고, 2.2를 제곱해서 결과값을 만들어서 이것을 그래프에 하나씩 좌표를 찍어봐야 할 것이다. 이는 컴퓨터도 다를 바가 없다. 만일 입력값의 범위가 10개가 아니라 1000개 라면 1000번을 반복해서 값을 만들아야할 것이고, 만일 제곱이 아니라 조금 더 복잡한 함수가 들어간다면 일이 더 커져서 결과적으로 연산속도가 대폭 늘어나게 될 것이다.
 
 ![week4-2](https://user-images.githubusercontent.com/70869138/94326388-822c8600-ffde-11ea-9530-fe06be832534.png)
 
 그렇기에 이 과정을 단순하게 만들기 위해 **해답표**를 미리 만들어 두면 된다. 입력값에 따른 출력값 - 즉, 합수를 미리 계산해서 결과 값만 해답표로 미리 작성해 두면 그래프를 그릴때 한결 빠르게 그릴 수가 있게 된다. 이것이 바로 **LUT(Look-Up Table)**이다. 처음 LUT를 작성할때는 시간이 걸리겠지만, 이것을 재사용할때는 해답표만 가지고 값만 대입해 주면 되므로 매번 그래프를 그릴때 아주 빠르게 그릴 수가 있게 된다. 그래서 결과적으로 출력값이 나오는 연산 과정이 모두 생략되기 때문에 변환 속도가 매우 빠르게 된다.
 
## **2. LUT의 종류**

### + **1D LUT**

 R, G, B의 채널은 각각 하나의 1차원의 배열을 지니고 있다. 다시 말해 1D LUT는 1차원이기 때문에 개념상 면이 아닌 선 혹은 곡선의 형태이며 R, G, B 채널당 각각 커브를 움직일 수 있다. 1D LUT의 특징은 Lift, Gamma, Gain, Contrast에 1:1로 매칭이 되고, Hue, Saturation의 보정 값은 1D LUT에 아무런 변화를 주지 못한다. 이러한 결과로 인해 흔히들 1D LUT를 흔히 밝기 값만 보정한다고 해서 **휘도 곡선**이라고 표현하고 있다. 하지만 Lift, Gamma, Gain 들을 R, G, B 채널 당 따로 보정을 했을 경우에는 휘도 외에도 색상까지 보정되는 결과를 얻을 수 있으므로 단지 휘도 값만 조절한다고 한정 지을 순 없다. 하지만 대다수 1D LUT는 R, G, B채널의 값이 동일한 경우가 대다수다.
 
 1. 아무런 값도 보정하지 않고 LUT를 만든 경우
 
![week4-3](https://user-images.githubusercontent.com/70869138/94326543-7e4d3380-ffdf-11ea-97dd-791961110be3.png)

 2. Lift, Gamma, Gain을 보정한 경우

![week4-4](https://user-images.githubusercontent.com/70869138/94326544-80af8d80-ffdf-11ea-9a7d-396ec8582bc1.png)

 3. Curve를 보정한 경우

![week4-5](https://user-images.githubusercontent.com/70869138/94326609-07646a80-ffe0-11ea-96ff-878f5e891031.png)

 추가로, 1D LUT 역시 R,G,B 3개의 채널별로 LUT를 만든다. Lift, Gamma, Gain, Curve는 모두 R, G, B, 채널별로 값을 보정할 수가 있고, 이 보정된 값은 1D LUT에 그대로 적용된다.

 4. Curve에서 RGB 각 채널별로 보정한 경우
 
 ![week4-6](https://user-images.githubusercontent.com/70869138/94327031-611a6400-ffe3-11ea-9602-e55057c5cfc4.png)
 
 즉, Lift, Gamma, Gain, Curve 등 에서 RGB 채널별로 각각 보정을 한 경우에는 1D LUT라고 하더라도 휘도 이외 **색상**까지 보정이 된다. 하지만 대부분의 1D LUT 들은 RGB 채널 값이 모두 동일한 경우가 많다. 즉, R=G=B 가 동일하면 휘도 커브가 된다. 
 
### + **3D LUT**

 3D LUT에서는 1D LUT에서 표현하지 못하는 Hue와 Saturation 보정 값까지 담을 수 있다. 이것이 가능한 이유는 3D LUT 에서는 X, Y, Z 축의 공간 과표로 표현하기 때문이다. 그리고 R, G, B 각 축을 따라 있는 점의 개수는 LUT의 사이즈에 따라 다르게 생성된다. 그 점을 중심으로 각각의 색상 채널에 대한 색상 변환을 할 수 있으며, 점 과 점 사이는 보간법을 이용해 근사치 값으로 보정이 되므로 LUT의 사이즈가 클수록 좀 더 정밀하게 색상을 컨트롤 할 수 있다. 현재 우리가 LUT라고 통칭해서 부르고 많이 사용하는 LUT가 바로 3D LUT라고 보시면 된다.

 LUT 사이즈에 따른 3차원 큐브에서 점의 분포

![week4-7](https://user-images.githubusercontent.com/70869138/94327174-37157180-ffe4-11ea-8332-d88e1ee5efd2.png)

![week4-8](https://user-images.githubusercontent.com/70869138/94336178-16690e00-001c-11eb-82c6-4e71c75c1635.png)


### + **그 외**

 서로 다른 텔레비전 표준 간의 변환(예: S-Log3에서 Rec-709로)에 사용되는 “테크니컬” LUT가 있으며, 거의 무한대의 다양한 시각적 모양과 스타일을 만드는 데 사용할 수 있는 크리에이티브 LUT가 있다.




